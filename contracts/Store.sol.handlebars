pragma solidity {{solidityVersion}};

import "forumable.sol";
import "orderable.sol";
import "aliasable.sol";
import "approvesAliases.sol";
import "Order.sol";

contract Store is forumable, aliasable, orderable, approvesAliases {

  function () payable {}

  {{#each contracts.store.variables}}
  {{>variable.sol variable=this}}
  {{/each}}

  {{#each contracts.store.structArrays}}
  {{>structArray.sol struct=this}}

  {{/each}}

	// function restoreProductUnits(uint index, uint quantity) requireOwnership {
	// 	products[index].units = products[index].units + quantity;
	// }

	// function depleteProductUnits(uint index, uint quantity) requireOwnership {
	// 	if(products[index].units < quantity) throw;
	// 	products[index].units = products[index].units - quantity;
	// }

 //  function addMessage(address orderAddr, bytes32 fileHash) requireOwnership {
 //    Order order = Order(orderAddr);
 //    order.addMessage(fileHash);
 //  }

 //  //TODO: cancel needs some tests
	// function cancel(address orderAddr) requireOwnership {
	// 	Order(orderAddr).cancel();
	// }

 //    //TODO: markAsShipped needs some tests
	// function markAsShipped(address orderAddr) requireOwnership {

 //    Order order = Order(orderAddr);

 //    uint productsLength = order.getProductsLength();

 //    for(uint i = 0; i < productsLength; i++) {
 //      uint index = order.getProductIndex(i);
 //      uint quantity = order.getProductQuantity(i);
 //      depleteProductUnits(index, quantity);
 //    }
 //    order.markAsShipped();

 //    verfifiedBuyers[Order(orderAddr)] = true;
 //  }

}